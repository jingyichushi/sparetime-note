# 缓存常见问题及其解决办法

## 为什么出现缓存？

随着互联网系统发展的逐步完善，提高系统的qps，目前的绝大部分系统都增加了缓存机制从而避免请求过多的直接与数据库操作从而造成系统瓶颈，极大的提升了用户体验和系统稳定性。



## 缓存穿透

### 问题描述

缓存穿透是指查询一个一定不存在的数据，因为缓存中也无该数据的信息，则会直接去数据库层进行查询，从系统层面来看像是穿透了缓存层直接达到db，从而称为缓存穿透，没有了缓存层的保护，这种查询一定不存在的数据对系统来说可能是一种危险，**如果有人恶意用这种一定不存在的数据来频繁请求系统**，不，准确的说是攻击系统，请求都会到达数据库层导致db瘫痪从而引起系统故障。

### 解决方案

缓存穿透业内的解决方案已经比较成熟，主要常用的有以下几种：

**1.bloom filter**（布隆过滤器）：类似于哈希表的一种算法，用所有可能的查询条件生成一个bitmap，在进行数据库查询之前会使用这个bitmap进行过滤，如果不在其中则直接过滤，从而减轻数据库层面的压力。（将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap**拦截**掉，从而避免了对底层存储系统的查询压力），其中**guava**中有实现BloomFilter算法（**后期会对guava cache进行介绍**）。



**2.空值缓存**：一种比较简单的解决办法，在第一次查询完不存在的数据后，将该key与对应的空值也放入缓存中，只不过设定为较短的失效时间，例如几分钟，这样则可以应对短时间的大量的该key攻击，设置为较短的失效时间是因为该值可能业务无关，存在意义不大，且该次的查询也未必是攻击者发起，无过久存储的必要，故可以早点失效。



## 缓存雪崩

### 问题描述

在普通的缓存系统中一般例如redis、memcache等中，我们会给缓存设置一个失效时间，但是如果所有的缓存的失效时间相同，那么在同一时间失效时，所有系统的请求都会发送到数据库层，db可能无法承受如此大的压力导致系统崩溃。

### 解决方案

**1.线程互斥**：只让一个线程构建缓存，其他线程等待构建缓存的线程执行完，重新从缓存获取数据才可以，每个时刻只有一个线程在执行请求，减轻了db的压力，但缺点也很明显，降低了系统的qps。



**2.交错失效时间**：这种方法时间比较简单粗暴，既然在同一时间失效会造成请求过多雪崩，那我们错开不同的失效时间即可从一定长度上避免这种问题，在缓存进行失效时间设置的时候，从某个适当的值域中随机一个时间作为失效时间即可。（时间岔开，确保大家的key不会落在同一个expire点上。）



## 缓存击穿

### 问题描述

缓存击穿实际上是缓存雪崩的一个特例，大家使用过微博的应该都知道，微博有一个热门话题的功能，用户对于热门话题的搜索量往往在一些时刻会大大的高于其他话题，这种我们成为系统的“热点“，由于系统中对这些热点的数据缓存也存在失效时间，在热点的缓存到达失效时间时，此时可能依然会有大量的请求到达系统，没有了缓存层的保护，这些请求同样的会到达db从而可能引起故障。击穿与雪崩的区别即在于击穿是对于特定的热点数据来说，而雪崩是全部数据。



### 解决方案

**1.二级缓存**

对于热点数据进行二级缓存，并对于不同级别的缓存设定不同的失效时间，则请求不会直接击穿缓存层到达数据库。这里参考了阿里双11万亿流量的缓存击穿解决方案，解决此问题的关键在于热点访问。由于热点可能随着时间的变化而变化，针对固定的数据进行特殊缓存是不能起到治本作用的，结合LRU算法能够较好的帮我们解决这个问题。LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”，最常见的实现是使用一个链表保存缓存数据。如果想对LRU进行了解的话，请参考我之前的文章：https://www.bcoder.top/2018/08/01/LRU-Catch%E5%AD%A6%E4%B9%A0/

**2.后台刷新**

后台定义一个job(定时任务)专门主动更新缓存数据.比如,一个缓存中的数据过期时间是30分钟,那么job每隔29分钟定时刷新数据(将从数据库中查到的数据更新到缓存中).

注：这种方案比较容易理解，但会增加系统复杂度。比较适合那些 key 相对固定,cache 粒度较大的业务，key 比较分散的则不太适合，实现起来也比较复杂。



**3.检查更新**

将缓存key的过期时间(绝对时间)一起保存到缓存中(可以拼接,可以添加新字段,可以采用单独的key保存.不管用什么方式,只要两者建立好关联关系就行).在每次执行get操作后,都将get出来的缓存过期时间与当前系统时间做一个对比,如果缓存过期时间-当前系统时间<=1分钟(自定义的一个值),则主动更新缓存.这样就能保证缓存中的数据始终是最新的

注：这种方案在特殊情况下也会有问题。假设缓存过期时间是12:00，而 11:59 到 12:00这 1 分钟时间里恰好没有 get 请求过来，又恰好请求都在 11:30 分的时 候高并发过来，那就悲剧了。这种情况比较极端，但并不是没有可能。因为“高并发”也可能是阶段性在某个时间点爆发。



**4.加锁**

方法1：

```java
public synchronized List<String> getData01() {
    List<String> result = new ArrayList<String>();
    // 从缓存读取数据
    result = getDataFromCache();
    if (result.isEmpty()) {
        // 从数据库查询数据
        result = getDataFromDB();
        // 将查询到的数据写入缓存
        setDataToCache(result);
    }
    return result;
}　　
```

注：这种方式确实能够防止缓存失效时高并发到数据库,但是缓存没有失效的时候,在从缓存中拿数据时需要排队取锁,这必然会大大的降低了系统的吞吐量.



方法2：

```java
static Object lock = new Object();

public List<String> getData02() {
    List<String> result = new ArrayList<String>();
    // 从缓存读取数据
    result = getDataFromCache();
    if (result.isEmpty()) {
        synchronized (lock) {
            // 从数据库查询数据
            result = getDataFromDB();
            // 将查询到的数据写入缓存
            setDataToCache(result);
        }
    }
    return result;
}　　
```

注：这个方法在缓存命中的时候,系统的吞吐量不会受影响,但是当缓存失效时,请求还是会打到数据库,只不过不是高并发而是阻塞而已.但是,这样会造成用户体验不佳,并且还给数据库带来额外压力.



方法3：

```java
public List<String> getData03() {
    List<String> result = new ArrayList<String>();
    // 从缓存读取数据
    result = getDataFromCache();
    if (result.isEmpty()) {
        synchronized (lock) {
            //双重判断,第二个以及之后的请求不必去找数据库,直接命中缓存
            // 查询缓存
            result = getDataFromCache();
            if (result.isEmpty()) {
                // 从数据库查询数据
                result = getDataFromDB();
                // 将查询到的数据写入缓存
                setDataToCache(result);
            }
        }
    }
    return result;
}
```

注：互斥锁的方式来实现，可以有效避免前面几种问题.

当然,在实际分布式场景中，我们还可以使用 redis、tair、zookeeper 等提供的分布式锁来实现.



如果是Redis，互斥锁可以这样(主要是利用**setnx**)：

```java
public String get(key) {  
      String value = redis.get(key);  
      if (value == null) { //代表缓存值过期  
              //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db  
              if (redis.setnx(key_mutex, 1, 3 * 60) == 1) {  //代表设置成功  
                  value = db.get(key);  
                  redis.set(key, value, expire_secs);  
                  redis.del(key_mutex);  
              } else {  //这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可  
                  sleep(50);  
                  get(key);  //重试  
              }  
      } else {  
          return value;        
      }  
 }  
```















